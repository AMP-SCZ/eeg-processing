function AMPSCZ_EEG_ERPplot( EEG, epochInfo, filterStr, writeFlag )
% ERP plots from the output of AMPSCZ_EEG_preproc.m
% 
% Usage:
% >> AMPSCZ_EEG_ERPplot( '/path/to/preprocMatFile.mat', [], [], writeFlag )
% or
% >> AMPSCZ_EEG_ERPplot( EEG, epochInfo, filterStr, writeFlag )
%
% where EEG and epochInfo are variables from a mat-file generated by AMPSCZ_EEG_preproc.m
%
% Written by: Spero Nicholas, NCIRE
%
% Dependencies: EEGLAB

% S:\bieegl01\Delta\napls3\matlab or github
% see grandAverage_NAPLS_LTP_ERPs.m loads mat-files for plotting
%     massUnivariateClusterTest_NAPLS_LTP_ERPs.m
%     plotLTPerps.m

			% BJR code
			% VODMMN
			% 	MMN plot Fz for standard & all deviant types
			% 	VOD plot Oz for standard
			% 	         Pz for target
			% 				find pos peak for Pz target [200,600]ms
			% 					topo mean standard w/i 25ms of peak
			% 					topo mean target   w/i 25ms of peak
			% #				find pos peak for Cz novel [200,600]ms
			% #					topo mean novel w/i 25ms of peak
			% AOD
			% 	no plots
			
			% New Spec
			% AOD or VOD
			%	plot Pz & Cz (possibly Fz too?)
			%   get target peak from Pz difference
			%       novel  peak from Cz difference
			% MMN
			%   plot Fz (& Cz?)
			
			% MMN in negative component 100-250 ms after stimulus
			
			% tpk = Peakmm3(nanmean(EEG.data(Pz,:,events==100),3)', EEG.times, 200,600,'pos');


		% From Gregory Light to Everyone:  04:21 PM
		% https://www.frontiersin.org/articles/10.3389/fninf.2015.00016/full			PREP?  bad channels iterative common average
		% https://sccn.ucsd.edu/wiki/Makoto's_preprocessing_pipeline					too ICA based but interesting


	narginchk( 1, 4 )

	AMPSCZdir = AMPSCZ_EEG_paths;
	if ~contains( which( 'hann.m' ), matlabroot )		% There's a hann.m in fieldrip, that's pretty useless, it just calls hanning.m
% 		error( 'remove Fieldtrip?' )
		if ~AMPSCZ_EEG_matlabPaths
			restoredefaultpath
		end
	end	
	if isempty( which( 'eeglab' ) )
% 		error( 'add EEGLAB' )
		if ~AMPSCZ_EEG_matlabPaths
			addpath( eegLabDir, '-begin' )
			eeglab
			drawnow
			close( gcf )
			% this clear is from EEGLAB uimenu callback
			% there's still a bunch of variables left behind, some global.
			clear global EEG ALLEEG LASTCOM CURRENTSET
		end
	end
	if ~contains( which( 'topoplot.m' ), 'modifications' )
		AMPSCZtools = fileparts( mfilename( 'fullpath' ) );
		addpath( fullfile( AMPSCZtools, 'modifications', 'eeglab' ), '-begin' )
	end

	% suppress warning about (xmax-xmin)*srate+1 ~= pnts?
% 	if isstruct( EEG ) && all( isfield( EEG, fieldnames( eeg_checkset( eeg_emptyset ) ) ) )
	blank = eeg_emptyset;
	blank.xmin = 1;				% eeg_checkset sets xmax to -1 instead
	blank = eeg_checkset( blank );
	if isstruct( EEG ) && all( isfield( EEG, fieldnames( blank ) ) )
% 		if ~isstruct( epochInfo ) || ~all( isfield( epochInfo, { 'latency', 'kTarget', 'kNovel', 'kCorrect', 'Nstandard', 'respLat' } ) )
		if ~isstruct( epochInfo ) || ~all( isfield( epochInfo, { 'latency', 'kStandard', 'kTarget', 'kNovel', 'kCorrect', 'respLat' } ) )
			error( 'invalid epochInfo structure' )
		end
		if isempty( filterStr )
			filterStr = '';		% force char
		elseif isnumeric( filterStr )
			if numel( filterStr ) ~= 2 || filterStr(2) <= filterStr(1)
				error( 'Invalid filter pass band, non-increasing' )
			end
			filterStr = sprintf( '[%g,%g]', filterStr );
		elseif ~ischar( filterStr )
			error( 'invalid filter pass band input, must be char or 2-element nuumeric' )
		end
	elseif ischar( EEG ) && exist( EEG, 'file' ) == 2 && strncmp( flip( EEG, 2 ), 'tam.', 4 )
		% get filter band string from filename or mat-file structure
		if ~isempty( filterStr )
			warning( 'filter band retrieved from mat-file name, user input ignored' )
		end
		filterStr = regexp( EEG, '_(\[[\d\.]+,([\d\.]+|Inf)\]).mat$', 'tokens', 'once' );
		if isempty( filterStr )
			error( 'no filter band info in file name' )
% 			filterStr = '';
		else
			filterStr = filterStr{1};
		end
		EEG = load( EEG, 'EEG', 'epochInfo' );%, 'passBand' );
		if ~isfield( EEG, 'EEG' )
			error( 'invalid mat-file' )
		end
		epochInfo = EEG.epochInfo;
		EEG       = EEG.EEG;
	else
		error( 'invalid EEG input' )
	end

	if exist( 'writeFlag', 'var' ) ~= 1
		writeFlag = [];
	elseif ~isempty( writeFlag ) && ~( islogical( writeFlag ) && isscalar( writeFlag ) )
		error( 'writeFlag must be empty or logical scalar' )
	end

	% concatenate epoch info across runs
	for fn = fieldnames( epochInfo )'
		epochInfo(1).(fn{1}) = [ epochInfo.(fn{1}) ];
	end
	epochInfo = epochInfo(1);
	
% 	tWidthTopo = 0;
	tWidthTopo = 25*2;
	
	% give each topo group to its own CLim or use same global limits as waveform plots?
	globalCmap = false;

	Ichan  = find( strcmp( { EEG.chanlocs.type }, 'EEG' ) );
	nChan  = numel( Ichan );
% 	nSamp  = EEG.pnts;
% 	nEpoch = EEG.trials;

	% pull out the latency=0 events from each epoch, cell array of 'S#' codes, should all be stim codes, not responses
	eventType = cellfun( @(u,v)u{[v{:}]==0}, { EEG.epoch.eventtype }, { EEG.epoch.eventlatency }, 'UniformOutput', false );
	if numel( eventType ) ~= EEG.trials
		error( 'huh?' )
	end
	
% 	chanSet = {
% 		'Cz-centered', { 'Cz', 'FC1',        'FC2', 'C1', 'C2', 'CP1', 'CPz', 'CP2' }
% 		'Pz-centered', { 'Pz', 'CP1', 'CPz', 'CP2', 'P1', 'P2', 'PO3', 'POz', 'PO4' }
% 	};
% 	chanSet = {
% 		'Cz', { 'Cz' }
% 		'Pz', { 'Pz' }
% 	};

	% Get epochName
	% EEG.comments will have VODMMN combined
	% there's got to be a better way to identify task! probably should just make it an input since it's saved in mat-files
	switch eventType{1}
		case { 'S  1', 'S  2', 'S  4', 1, 2, 4 }
			epochName = 'AOD';
			tWinPlot  = [ -100, 600 ];	% (ms)
			% { label, channel members }
			chanSet = {
% 				'Fz', { 'Fz' }		% add 100 pixels to figure height if you use this? useful for AOD novel heralds?
				'Cz', { 'Cz' }
				'Pz', { 'Pz' }
			};
			figSize  = [ 1000+200, 700+100 ];
		case { 'S 16', 'S 18', 16, 18 }
			epochName = 'MMN';
			tWinPlot  = [ -100, 500 ];	% (ms)
			chanSet = {
				'Fz', { 'Fz' }
				'Cz', { 'Cz' }
				'Frontal 6', { 'F3', 'Fz', 'F4', 'C3', 'Cz', 'C4' }
			};
			figSize  = [ 500+200, 700+150*1 ];		% add height for 3-row w/ frontal 6
		case { 'S 32', 'S 64', 'S128', 32, 64, 128 }
			epochName = 'VOD';
			tWinPlot  = [ -100, 600 ];	% (ms)
% 			chanSet = {
% 				'Pz', { 'Pz' }		% target & peak detection
% 				'Oz', { 'Oz' }		% standard
% 			};
			chanSet = {
				'Cz', { 'Cz' }		%  novel - standard
				'Pz', { 'Pz' }		% target - standard
			};
			figSize  = [ 1000+200, 700+100 ];
		case { 'S  8', 8 }
			epochName = 'ASSR';
			tWinPlot  = [ -100, 600 ];	% (ms)
% 		case { 'S 20 ', 20 }
% 			epochName = 'RestEO';
% 		case { 'S 24', 24 }
% 			epochName = 'RestEC';
		otherwise
			error( 'can''t identify task' )
	end

	jTime = EEG.times >= tWinPlot(1) & EEG.times <= tWinPlot(2);
	jT0   = find( jTime, 1, 'first' ) - 1;
	nTime = nnz( jTime );

	% convert cell arrays of channel names to numeric indices
	nSet = size( chanSet, 1 );		% # waveform axes
	for iSet = 1:nSet
%		     chanSet{iSet,2}   = eeg_chaninds( EEG, chanSet{iSet,2} );			% beware: eeg_chaninds.m sorts indices
		[ ~, chanSet{iSet,2} ] = ismember( chanSet{iSet,2}, { EEG.chanlocs(Ichan).labels } );
		if any( chanSet{iSet,2} == 0 )
			error( 'unknown channel(s)' )
		end
	end

		% double-check EEG structure against epochInfo?
%		[ standardCode, targetCode, novelCode ] = AMPSCZ_EEG_eventCodes( epochName );
%		if ~isempty( [ standardCode, targetCode, novelCode ] )
%			if numel( eventType ) ~= numel( epochInfo.kTarget )
%				error( 'epoch event type bug' )
%			elseif ~isempty( targetCode ) && ~all( strcmp( eventType( epochInfo.kTarget ), targetCode ) )
%				error( 'epoch event type bug' )
%			elseif ~isempty(  novelCode ) && ~all( strcmp( eventType( epochInfo.kNovel  ),  novelCode ) )
%				error( 'epoch event type bug' )
%			end
%		end

% 	[ standardCode, targetCode, novelCode ] = AMPSCZ_EEG_eventCodes( epochName );
	% non-rejected epochs
	kEpoch = shiftdim( ~isnan( EEG.data(1,1,:) ), 1 );
	nanFlag = 'includenan';		% shouldn't be any NaNs, include them as safety
	
% 	topoOpts = { 'style', 'map', 'electrodes', 'pts', 'nosedir', '+X', 'conv', 'on', 'shading', 'interp' };		% electrodes: 'pts' or 'ptslabels'?
	topoOpts = AMPSCZ_EEG_topoOptions( jet( 256 ) );

	fontSize = 10;
% 	if size( EEG.comments, 1 ) == 1
% 		iComment = 1;
% 	else
% 		iComment = 
% 	end
	subjSess = regexp( EEG.comments(end,:), '^Original file: sub-([A-Z]{2}\d{5})_ses-(\d{8})_task-\S+_run-\d+_eeg.eeg$', 'tokens', 'once' );
			
	% stop automatic datatips - they're super annoying!
	set( groot , 'defaultAxesCreateFcn' , 'disableDefaultInteractivity(gca)' )

	hFig = gobjects;%( 1, 2 );
	
			% trying to salvage partial runs where events went out of epoch bounds
			% thus EEG.epoch dimensions didn't match epochInfo structure.
			% worked in some cases, but not all.  had to change AMPSCZ_EEG_preproc.m instead.
			nStim = numel( epochInfo.latency );
			if EEG.trials ~= nStim
				error( '# trials (%d) vs epochInfo (%d) mismatch', EEG.trials, nStim )
			end
% 			if EEG.trials < nStim
% 				% index of zero-latency event in each epoch
% 				Iepoch = cellfun( @(u)find([u{:}]==0), { EEG.epoch.eventlatency }, 'UniformOutput', false );
% 				% unique epoch event types
% 				eventTypes = unique( cellfun( @(u,v)u{v}, { EEG.epoch.eventtype }, Iepoch, 'UniformOutput', false ) );
% 				% original event indices of epoch types in full event stream
% 				Ievent = unique( [ EEG.event(ismember( { EEG.event.type }, eventTypes )).urevent ], 'sorted' );
% 				if numel( Ievent ) ~= nStim
% 					disp([ numel( Ievent ), nStim ])
% 					error( 'Can''t match remaining epochs to original stimulus sequence' )
% 				end
% 				% logical indices of epochInfo items to keep
% 				Ievent = ismember( Ievent, cellfun( @(u,v)u{v}, { EEG.epoch.eventurevent }, Iepoch ) );
% 				% remove events that never became epochs
% 				for fn = fieldnames( epochInfo )'
% 					epochInfo.(fn{1}) = epochInfo.(fn{1})(Ievent);
% 				end
% 			end

	switch epochName

		case 'MMN'

			Kstandard = epochInfo.kStandard;
			Kdeviant  = epochInfo.kNovel;
			Nstandard = nnz( Kstandard );
			Ndeviant  = nnz( Kdeviant );
			% only analyze correct responses?		don't worry about button presses in MMN task.  DM 12/13/21
% 			Kstandard(Kstandard) = epochInfo.kCorrect(Kstandard);
% 			Kdeviant(Kdeviant)   = epochInfo.kCorrect(Kdeviant);
			% non-rejected epochs
			Kstandard(Kstandard) = kEpoch(Kstandard);
			Kdeviant(Kdeviant)   = kEpoch(Kdeviant);
			% average across epochs
			YmStandard = mean( EEG.data(Ichan,jTime,Kstandard), 3, nanFlag );
			YmDeviant  = mean( EEG.data(Ichan,jTime,Kdeviant ), 3, nanFlag );
			% average aross channels, #sets x #samples matrices
			[ ymStandard, ymDeviant ] = deal( zeros( nSet, nTime ) );
			for iSet = 1:nSet
				ymStandard(iSet,:) = mean( YmStandard(chanSet{iSet,2},:), 1, nanFlag );
				ymDeviant(iSet,:)  = mean(  YmDeviant(chanSet{iSet,2},:), 1, nanFlag );
			end
			% plot limits
			yRange0 = yRangeFcn( cat( 3, YmStandard, YmDeviant, YmDeviant - YmStandard ) );
			yRange  = yRangeFcn( cat( 3, ymStandard, ymDeviant, ymDeviant - ymStandard ) );
			kSet = strcmp( chanSet(:,1), 'Fz' );
			if nnz( kSet ) ~= 1
				error( 'invalid channel set name' )
			end
			kPk = EEG.times(jTime) >= 80 & EEG.times(jTime) <= 250;
			[ ~, jPk ] = findpeaks( ymStandard(kSet,kPk) - ymDeviant(kSet,kPk) );
			switch numel( jPk )
				case 1
				case 0		% use an endpoint if no peaks?
					[ ~, jPk ] = min( ymDeviant(kSet,kPk) - ymStandard(kSet,kPk) );
				otherwise
% 					EEG.times(jPk+jT0)
					ikPk = find( kPk );
					[ ~, ijPk ] = min( ymDeviant(kSet,ikPk(jPk)) - ymStandard(kSet,ikPk(jPk)) );
					jPk = jPk(ijPk);
% 					EEG.times(jPk+jT0)
					clear ikPk
			end
			jPk(:) = jPk + find( kPk, 1, 'first' ) - 1;
			jt = jPk + jT0;
			
			[ tmStandard, tmDeviant ] = deal( nan( nChan, 2 ) );
			if tWidthTopo == 0
				tmStandard(:,1) = YmStandard(:,jPk);
				tmDeviant(:,1)  =  YmDeviant(:,jPk);
				tStr1 = sprintf( 'Peak\n%0.0f ms', EEG.times(jt) );
			else
				tAvg = EEG.times(jt) + [ -1, 1 ]*tWidthTopo/2;
				jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
				tmStandard(:,1) = mean( YmStandard(:,jAvg), 2, nanFlag );
				tmDeviant(:,1)  = mean(  YmDeviant(:,jAvg), 2, nanFlag );
				tStr1 = sprintf( 'Peak\n%0.0f \\pm %0.0f ms', EEG.times(jt), tWidthTopo/2 );
			end
			tFix = 138;
			wFix =  80;
			tAvg = tFix + [ -1, 1 ]*wFix/2;
			jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
			tmStandard(:,2) = mean( YmStandard(:,jAvg), 2, nanFlag );
			tmDeviant(:,2)  = mean(  YmDeviant(:,jAvg), 2, nanFlag );
% 			tStr2 = sprintf( '[ %0.0f, %0.0f ] ms', tAvg );
			tStr2 = sprintf( 'Fixed Window\n%0.0f \\pm %0.0f ms', tFix, wFix/2 );

			hFig(1) = figure( 'Position', [ 600, 100, figSize ], 'Colormap', jet(256), 'MenuBar', 'none' );		% 225% SCN laptop
			hAx     = gobjects( 3+2*nSet+4, 1 );
			hTopo   = gobjects(          4, 1 );

			topoOpts = [ topoOpts, { 'maplimits', yRange } ];
			pkColor = [ 1, 0, 0 ];
			
			axL  = 0.1;
			axR  = 0.05;
			axT  = 0.1;
			axB  = 0.05;
			axGh = 0.05;
			axGv = [ 0.02, 0.08, 0.05 ];		% bewteen waveplots, between waves & topos, between topos
			axH = ( 1 - axT - axB - axGv(1)*nSet - axGv(2) - axGv(3) ) / ( 1 + nSet + 2 );
			axW = ( 1 - axL - axR - axGh*2 ) / 3;

			% Plot
			% butterflies
			py = 1 - axT - axH;
			hAx(1) = subplot( 'Position', [ axL,              py, axW, axH ] );
			hAx(2) = subplot( 'Position', [ axL+ axW+axGh,    py, axW, axH ] );
			hAx(3) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );
			plot( hAx(1), EEG.times(jTime), YmStandard' )
			plot( hAx(2), EEG.times(jTime), YmDeviant' )
			plot( hAx(3), EEG.times(jTime), ( YmDeviant - YmStandard )' )
% 			ylim( hAx(1), [ -1, 1 ] * max( abs( YmStandard             ), [], 'all' ) * 1.05 )
% 			ylim( hAx(2), [ -1, 1 ] * max( abs( YmDeviant              ), [], 'all' ) * 1.05 )
% 			ylim( hAx(3), [ -1, 1 ] * max( abs( YmDeviant - YmStandard ), [], 'all' ) * 1.05 )
			% single-channel waveforms
			for iSet = 1:nSet
				py = 1 - axT  - ( axH + axGv(1) )*(1+iSet) + axGv(1);
				hAx(3+2*iSet-1) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet-1 );
				hAx(3+2*iSet)   = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet );
				plot( hAx(3+2*iSet-1), EEG.times(jTime), ymStandard(iSet,:), 'k', EEG.times(jTime), ymDeviant(iSet,:), 'r' )
				plot( hAx(3+2*iSet)  , EEG.times(jTime), ymDeviant(iSet,:) - ymStandard(iSet,:), 'r' )
			end
			% topographies
			% -- peak detection
			py(:) = py - axGv(2) - axH;
			hAx(3+2*nSet+1) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet+1 );
				hTopo(1) = topoplot( tmDeviant(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(3+2*nSet+2) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet+2 );
				hTopo(2) = topoplot( tmDeviant(:,1) - tmStandard(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			% -- fixed time range
			py(:) = py - axGv(3) - axH;
			hAx(3+2*nSet+3) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet+3 );
				hTopo(3) = topoplot( tmDeviant(:,2), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(3+2*nSet+4) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );	%subplot( nSet+2, 2, 2*iSet+4 );
				hTopo(4) = topoplot( tmDeviant(:,2) - tmStandard(:,2), EEG.chanlocs(Ichan), topoOpts{:} );
				
			set( hAx(1:3+nSet*2), 'XLim', tWinPlot, 'FontSize', 8, 'XGrid', 'on', 'YGrid', 'on' )
			set( hAx(1:3+nSet*2), 'XTick', fix(tWinPlot(1)/100)*100:100:fix(tWinPlot(2)/100)*100 )
% 			set( hAx(1:3+nSet*2), 'XTick', floor(tWinPlot(1)/100)*100:100:ceil(tWinPlot(2)/100)*100 )
			set( hAx(1:3), 'YLim', yRange0 )
			set( hAx(1:3), 'YTick', yTickFcn( yRange0(2) ) )
			set( hAx(4:3+nSet*2), 'YLim', yRange, 'CLim', yRange )
			set( hAx(4:3+nSet*2), 'YTick', yTickFcn( yRange(2) ) )
			set( hAx(2:3+(nSet-1)*2), 'XTickLabel', '' )
% 			set( hAx(iSet), 'UserData', iSet )
			set( hAx(3+nSet*2+1:end), 'XLim', [ -0.5, 0.5 ], 'YLim', [ -0.4, 0.45 ], 'CLim', yRange )

			if ~globalCmap
				wColorbar = 0.3;
				zMax = max( abs( [ tmDeviant(:); tmDeviant(:) - tmStandard(:) ] ) );
				set( hAx(3+2*nSet+(1:4)), 'CLim', [ -1, 1 ] * zMax )
				hColorbar = subplot( 'Position', [ axL+ axW+axGh   , axB*(1-wColorbar)*0.7, axW*2+axGh, axB*wColorbar ], 'Parent', hFig(1) );
				image( hColorbar, linspace( -zMax, zMax, 256 ), 0, (1:256) )
				set( hColorbar, 'YTick', [] )
			end

% 			title( hAx(1), sprintf( '{\\fontsize{%d}%s\n{\\rm%s  (%s-%s-%s)}}\nStandard (%d)', fontSize+2,...
% 				epochName, subjSess{1}, subjSess{2}(1:4), subjSess{2}(5:6), subjSess{2}(7:8), nnz( Kstandard ) ), 'FontSize', fontSize )
% 			title( hAx(2), sprintf( '\\color{red}Deviant (%d)', nnz( Kdeviant ) ), 'FontSize', fontSize )
			title( hAx(1), sprintf( 'Standard (%d/%d)', nnz( Kstandard ), Nstandard ), 'FontSize', fontSize )
			title( hAx(2), sprintf( '{\\fontsize{%d}%s\n{\\rm%s  (%s-%s-%s)}}\n\\color{red}Deviant (%d/%d)', fontSize+2,...
				epochName, subjSess{1}, subjSess{2}(1:4), subjSess{2}(5:6), subjSess{2}(7:8), nnz( Kdeviant ), Ndeviant ), 'FontSize', fontSize )
			title( hAx(3), '\color{red}Deviant - Standard', 'FontSize', fontSize )
			ylabel( hAx(1), '(\muV)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			for iSet = 1:nSet
				ylabel( hAx(3+2*iSet-1), [ chanSet{iSet,1}, ' (\muV)' ], 'FontSize', fontSize, 'FontWeight', 'bold' )
			end
			xlabel( hAx(1)         , 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(3+2*nSet-1), 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(3+2*nSet)  , 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
% 			title(  hAx(3+2*nSet+1), 'Deviant', 'FontSize', fontSize )
% 			title(  hAx(3+2*nSet+2), 'Deviant - Standard', 'FontSize', fontSize )
			ylabel( hAx(3+2*nSet+1), tStr1, 'Visible', 'on', 'Color', pkColor, 'FontSize', fontSize, 'FontWeight', 'bold' )
			ylabel( hAx(3+2*nSet+3), tStr2, 'Visible', 'on', 'Color',     'k', 'FontSize', fontSize, 'FontWeight', 'bold' )

			iSet(:) = find( kSet );
			if tWidthTopo == 0
				line( hAx(3+2*iSet), EEG.times([jt,jt]), yRange, 'Color', pkColor, 'LineStyle', '--' )
			else
				uistack( patch( hAx(3+2*iSet), EEG.times(jt)+[-1,1,1,-1]*tWidthTopo/2, yRange([1 1 2 2]), repmat( 0.75, 1, 3 ), 'EdgeColor', 'none', 'FaceAlpha', 0.5 ), 'bottom' )
% 				line( hAx(3+2*iSet), EEG.times([jt,jt]), yRange, 'Color', pkColor, 'LineStyle', '--' )
			end

%{
			hAx2 = gobjects( 1, 3 );
			hFig(2) = figure( 'Position', [ 650, 200, 1000, 250 ], 'MenuBar', 'none' );
			hAx2(1) = subplot( 1, 3, 1 );
				plot( EEG.times(jTime), YmStandard' )
				ylim( [ -1, 1 ] * max( abs( YmStandard ), [], 'all' ) * 1.05 )
			hAx2(2) = subplot( 1, 3, 2 );
				plot( EEG.times(jTime), YmDeviant' )
				ylim( [ -1, 1 ] * max( abs( YmDeviant ), [], 'all' ) * 1.05 )
			hAx2(3) = subplot( 1, 3, 3 );
				plot( EEG.times(jTime), ( YmDeviant - YmStandard )' )
				ylim( [ -1, 1 ] * max( abs( YmDeviant - YmStandard ), [], 'all' ) * 1.05 )
			set( hAx2, 'XGrid', 'on', 'YGrid', 'on', 'XLim', tWinPlot )
			set([
					title(  hAx2(1), sprintf( 'Standard (%d)', nnz( Kstandard ) ) )
					title(  hAx2(2), sprintf(  'Deviant (%d)', nnz( Kdeviant  ) ) )
					title(  hAx2(3), 'Deviant - Standard' )
					ylabel( hAx2(1), sprintf( '%s\n%s-%s-%s\nMean %s ERP (\\muV)', subjSess{1}, subjSess{2}(1:4), subjSess{2}(5:6), subjSess{2}(7:8), epochName ) )
					xlabel( hAx2(1), 'Time (ms)' )
					xlabel( hAx2(2), 'Time (ms)' )
					xlabel( hAx2(3), 'Time (ms)' )
				], 'FontSize', 12 )
%}

		case { 'VOD', 'AOD' }

			% what to do about standard sounds preceding novels in AOD paradigm
			if strcmp( epochName, 'AOD' )
				% 0 = ignore, don't plot
				% 1 = plot but keep all standards in other analyses
				% 2 = exclude heralds from other analyses
% 				plotHeralds = 1;
				plotHeralds = 0;
			else
				plotHeralds = 0;
			end
			Kstandard  = epochInfo.kStandard;
			Ktarget    = epochInfo.kTarget;
			Knovel     = epochInfo.kNovel;
			KpreNovel  = [ Knovel(2:end) , false ];
			KpreTarget = [ Ktarget(2:end), false ];
			Nstandard  = nnz( Kstandard );
			Ntarget    = nnz( Ktarget );
			Nnovel     = nnz( Knovel );
			% only analyze correct responses?		don't worry about button presses in MMN task.  DM 12/13/21
			Kstandard(Kstandard) = epochInfo.kCorrect(Kstandard);
			Ktarget(Ktarget)     = epochInfo.kCorrect(Ktarget);
			Knovel(Knovel)       = epochInfo.kCorrect(Knovel);
			% non-rejected epochs
			Kstandard(Kstandard) = kEpoch(Kstandard);
			Ktarget(Ktarget)     = kEpoch(Ktarget);
			Knovel(Knovel)       = kEpoch(Knovel);
			% average across epochs
			if plotHeralds == 2
				YmStandard = mean( EEG.data(Ichan,jTime,Kstandard & ~KpreNovel), 3, nanFlag );
			else
				YmStandard = mean( EEG.data(Ichan,jTime,Kstandard), 3, nanFlag );
			end
			YmTarget   = mean( EEG.data(Ichan,jTime,Ktarget  ), 3, nanFlag );
			YmNovel    = mean( EEG.data(Ichan,jTime,Knovel   ), 3, nanFlag );
			% average aross channels, #sets x #samples matrices
			[ ymStandard, ymTarget, ymNovel ] = deal( zeros( nSet, nTime ) );
			for iSet = 1:nSet
				ymStandard(iSet,:) = mean( YmStandard(chanSet{iSet,2},:), 1, nanFlag );
				ymTarget(iSet,:)   = mean(   YmTarget(chanSet{iSet,2},:), 1, nanFlag );
				ymNovel(iSet,:)    = mean(    YmNovel(chanSet{iSet,2},:), 1, nanFlag );
			end
			% plot limits
			yRange0 = yRangeFcn( cat( 3, YmStandard, YmTarget, YmNovel, YmTarget - YmStandard, YmNovel - YmStandard ) );
			yRange  = yRangeFcn( cat( 3, ymStandard, ymTarget, ymNovel, ymTarget - ymStandard, ymNovel - ymStandard ) );
			kSetT = strcmp( chanSet(:,1), 'Pz' );
			if nnz( kSetT ) ~= 1
				error( 'invalid channel set name' )
			end
			kSetN = strcmp( chanSet(:,1), 'Cz' );
			if nnz( kSetN ) ~= 1
				error( 'invalid channel set name' )
			end
			kPk = EEG.times(jTime) >= 200 & EEG.times(jTime) <= 500;
			[ ~, jPkT ] = findpeaks( ymTarget(kSetT,kPk) - ymStandard(kSetT,kPk) );
			[ ~, jPkN ] = findpeaks(  ymNovel(kSetN,kPk) - ymStandard(kSetN,kPk) );
			switch numel( jPkT )
				case 1
				case 0		% use an endpoint if no peaks?
					[ ~, jPkT ] = max( ymTarget(kSetT,kPk) - ymStandard(kSetT,kPk) );
				otherwise
					ikPk = find( kPk );
					[ ~, ijPk ] = max( ymTarget(kSetT,ikPk(jPkT)) - ymStandard(kSetT,ikPk(jPkT)) );
					jPkT = jPkT(ijPk);
					clear ikPk
			end
			switch numel( jPkN )
				case 1
				case 0		% use an endpoint if no peaks?
					[ ~, jPkN ] = max( ymNovel(kSetN,kPk) - ymStandard(kSetN,kPk) );
				otherwise
					ikPk = find( kPk );
					[ ~, ijPk ] = max( ymNovel(kSetN,ikPk(jPkN)) - ymStandard(kSetN,ikPk(jPkN)) );
					jPkN = jPkN(ijPk);
					clear ikPk
			end
			jPkT(:) = jPkT + find( kPk, 1, 'first' ) - 1;
			jPkN(:) = jPkN + find( kPk, 1, 'first' ) - 1;
			jtT = jPkT + jT0;
			jtN = jPkN + jT0;
			
			[ tmStandardT, tmStandardN, tmTarget, tmNovel ] = deal( nan( nChan, 2 ) );
			if tWidthTopo == 0
				tmStandardT(:,1) = YmStandard(:,jPkT);
				tmStandardN(:,1) = YmStandard(:,jPkN);
				tmTarget(:,1)    =   YmTarget(:,jPkT);
				tmNovel(:,1)     =    YmNovel(:,jPkN);
				tStr1T = sprintf( 'Peak\n%0.0f ms', EEG.times(jtT) );
				tStr1N = sprintf( 'Peak\n%0.0f ms', EEG.times(jtN) );
			else
				tAvg = EEG.times(jtT) + [ -1, 1 ]*tWidthTopo/2;
				jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
				tmStandardT(:,1) = mean( YmStandard(:,jAvg), 2, nanFlag );
				tmTarget(:,1)    = mean(   YmTarget(:,jAvg), 2, nanFlag );
				tAvg = EEG.times(jtN) + [ -1, 1 ]*tWidthTopo/2;
				jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
				tmStandardN(:,1) = mean( YmStandard(:,jAvg), 2, nanFlag );
				tmNovel(:,1)     = mean(    YmNovel(:,jAvg), 2, nanFlag );
				tStr1T = sprintf( 'Peak\n%0.0f \\pm %0.0f ms', EEG.times(jtT), tWidthTopo/2 );
				tStr1N = sprintf( 'Peak\n%0.0f \\pm %0.0f ms', EEG.times(jtN), tWidthTopo/2 );
			end
			if strcmp( epochName, 'AOD' )
				tFix = 330;		% AOD ~ 330 target, 320 novel; VOD ~ 410 target, 355 novel
			else
				tFix = 423;
			end
			wFix = 80;
			tAvg = tFix + [ -1, 1 ]*wFix/2;
			jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
			tmStandardT(:,2) = mean( YmStandard(:,jAvg), 2, nanFlag );
			tmTarget(:,2)    = mean(   YmTarget(:,jAvg), 2, nanFlag );
			tStr2T = sprintf( 'Fixed Window\n%0.0f \\pm %0.0f ms', tFix, wFix/2 );

			if strcmp( epochName, 'AOD' )
				tFix = 325;
			else
				tFix = 344;
			end
% 			wFix = 80;
			tAvg = tFix + [ -1, 1 ]*wFix/2;
			jAvg = EEG.times(jTime) >= tAvg(1) & EEG.times(jTime) <= tAvg(2);
			tmStandardN(:,2) = mean( YmStandard(:,jAvg), 2, nanFlag );
			tmNovel(:,2)     = mean(    YmNovel(:,jAvg), 2, nanFlag );
			tStr2N = sprintf( 'Fixed Window\n%0.0f \\pm %0.0f ms', tFix, wFix/2 );

			hFig(1) = figure( 'Position', [ 600, 150, figSize ], 'Colormap', jet(256), 'MenuBar', 'none' );		% 225% SCN laptop
			hAx     = gobjects( 5+4*nSet+8, 1 );
			hTopo   = gobjects(          8, 1 );
			
			topoOpts = [ topoOpts, { 'maplimits', yRange } ];
			pkColorT = [ 0, 0, 1 ];
			pkColorN = [ 1, 0, 0 ];
			
			axL  = 0.1;
			axR  = 0.05;
			axT  = 0.1;
			axB  = 0.05;
			axGh = 0.05;
			axGv = [ 0.02, 0.08, 0.05 ];		% bewteen waveplots, between waves & topos, between topos
			axH = ( 1 - axT - axB - axGv(1)*nSet - axGv(2) - axGv(3) ) / ( 1 + nSet + 2 );
			axW = ( 1 - axL - axR - axGh*4 ) / 5;

			% Plot
			% butterflies
			py = 1 - axT - axH;
			hAx(1) = subplot( 'Position', [ axL,              py, axW, axH ] );
			hAx(2) = subplot( 'Position', [ axL+ axW+axGh,    py, axW, axH ] );
			hAx(3) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );
			hAx(4) = subplot( 'Position', [ axL+(axW+axGh)*3, py, axW, axH ] );
			hAx(5) = subplot( 'Position', [ axL+(axW+axGh)*4, py, axW, axH ] );
			plot( hAx(1), EEG.times(jTime), YmStandard' )
			plot( hAx(2), EEG.times(jTime), YmTarget' )
			plot( hAx(3), EEG.times(jTime), ( YmTarget - YmStandard )' )
			plot( hAx(4), EEG.times(jTime), YmNovel' )
			plot( hAx(5), EEG.times(jTime), ( YmNovel - YmStandard )' )
% 			ylim( hAx(1), [ -1, 1 ] * max( abs( YmStandard            ), [], 'all' ) * 1.05 )
% 			ylim( hAx(2), [ -1, 1 ] * max( abs( YmTarget              ), [], 'all' ) * 1.05 )
% 			ylim( hAx(3), [ -1, 1 ] * max( abs( YmTarget - YmStandard ), [], 'all' ) * 1.05 )
% 			ylim( hAx(3), [ -1, 1 ] * max( abs( YmNovel               ), [], 'all' ) * 1.05 )
% 			ylim( hAx(5), [ -1, 1 ] * max( abs( YmNovel  - YmStandard ), [], 'all' ) * 1.05 )
			% single-channel waveforms
			for iSet = 1:nSet
				py = 1 - axT  - ( axH + axGv(1) )*(1+iSet) + axGv(1);
				hAx(5+4*iSet-3) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );
				hAx(5+4*iSet-2) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );
				hAx(5+4*iSet-1) = subplot( 'Position', [ axL+(axW+axGh)*3, py, axW, axH ] );
				hAx(5+4*iSet)   = subplot( 'Position', [ axL+(axW+axGh)*4, py, axW, axH ] );
				plot( hAx(5+4*iSet-3), EEG.times(jTime), ymStandard(iSet,:), 'k', EEG.times(jTime), ymTarget(iSet,:), 'b' )
				plot( hAx(5+4*iSet-2), EEG.times(jTime),   ymTarget(iSet,:) - ymStandard(iSet,:), 'b' )
				plot( hAx(5+4*iSet-1), EEG.times(jTime), ymStandard(iSet,:), 'k', EEG.times(jTime), ymNovel(iSet,:), 'r' )
				plot( hAx(5+4*iSet)  , EEG.times(jTime),    ymNovel(iSet,:) - ymStandard(iSet,:), 'r' )
			end
			% topographies
			% -- peak detection
			py(:) = py - axGv(2) - axH;
			hAx(5+4*nSet+1) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );
				hTopo(1) = topoplot( tmTarget(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+2) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );
				hTopo(2) = topoplot( tmTarget(:,1) - tmStandardT(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+3) = subplot( 'Position', [ axL+(axW+axGh)*3, py, axW, axH ] );
				hTopo(3) = topoplot( tmNovel(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+4) = subplot( 'Position', [ axL+(axW+axGh)*4, py, axW, axH ] );
				hTopo(4) = topoplot( tmNovel(:,1) - tmStandardN(:,1), EEG.chanlocs(Ichan), topoOpts{:} );
			% -- fixed time range
			py(:) = py - axGv(3) - axH;
			hAx(5+4*nSet+5) = subplot( 'Position', [ axL+ axW+axGh   , py, axW, axH ] );
				hTopo(5) = topoplot( tmTarget(:,2), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+6) = subplot( 'Position', [ axL+(axW+axGh)*2, py, axW, axH ] );
				hTopo(6) = topoplot( tmTarget(:,2) - tmStandardT(:,2), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+7) = subplot( 'Position', [ axL+(axW+axGh)*3, py, axW, axH ] );
				hTopo(7) = topoplot( tmNovel(:,2), EEG.chanlocs(Ichan), topoOpts{:} );
			hAx(5+4*nSet+8) = subplot( 'Position', [ axL+(axW+axGh)*4, py, axW, axH ] );
				hTopo(8) = topoplot( tmNovel(:,2) - tmStandardN(:,2), EEG.chanlocs(Ichan), topoOpts{:} );

			set( hAx(1:5+nSet*4), 'XLim', tWinPlot, 'FontSize', 8, 'XGrid', 'on', 'YGrid', 'on' )
			set( hAx(1:5+nSet*4), 'XTick', fix(tWinPlot(1)/100)*100:100:fix(tWinPlot(2)/100)*100 )
% 			set( hAx(1:5+nSet*4), 'XTick', floor(tWinPlot(1)/100)*100:100:ceil(tWinPlot(2)/100)*100 )
			set( hAx(1:5), 'YLim', yRange0 )
			set( hAx(1:5), 'YTick', yTickFcn( yRange0(2) ) )
			set( hAx(6:5+nSet*4), 'YLim', yRange, 'CLim', yRange )
			set( hAx(6:5+nSet*4), 'YTick', yTickFcn( yRange(2) ) )
			set( hAx(2:5+(nSet-1)*4), 'XTickLabel', '' )
% 			set( hAx(iSet), 'UserData', iSet )
			set( hAx(5+nSet*4+1:end), 'XLim', [ -0.5, 0.5 ], 'YLim', [ -0.4, 0.45 ], 'CLim', yRange )
			
			if ~globalCmap
				wColorbar = 0.3;

				zMax = max( abs( [ tmTarget(:); tmTarget(:) - tmStandardT(:) ] ) );
				set( hAx(5+4*nSet+[1 2 5 6]), 'CLim', [ -1, 1 ] * zMax )
				hColorbar = subplot( 'Position', [ axL+ axW+axGh   , axB*(1-wColorbar)*0.7, axW*2+axGh, axB*wColorbar ], 'Parent', hFig(1) );
				image( hColorbar, linspace( -zMax, zMax, 256 ), 0, (1:256) )
				set( hColorbar, 'YTick', [] )

				zMax(:) = max( abs( [ tmNovel(:); tmNovel(:) - tmStandardN(:) ] ) );
				set( hAx(5+4*nSet+[3 4 7 8]), 'CLim', [ -1, 1 ] * zMax )
				hColorbar = subplot( 'Position', [ axL+(axW+axGh)*3, axB*(1-wColorbar)*0.7, axW*2+axGh, axB*wColorbar ], 'Parent', hFig(1) );
				image( hColorbar, linspace( -zMax, zMax, 256 ), 0, (1:256) )
				set( hColorbar, 'YTick', [] )
			end

			if plotHeralds == 2
				title( hAx(1), sprintf( 'Standard (%d/%d)', nnz( Kstandard & ~KpreNovel ), Nstandard - Nnovel ), 'FontSize', fontSize )
			else
				title( hAx(1), sprintf( 'Standard (%d/%d)', nnz( Kstandard ), Nstandard ), 'FontSize', fontSize )
			end
			title( hAx(2), sprintf( '\\color{blue}Target (%d/%d)', nnz( Ktarget ), Ntarget ), 'FontSize', fontSize )
			title( hAx(3), sprintf( '{\\fontsize{%g}%s\n{\\rm%s  (%s-%s-%s)}}\n\\color{blue}Target - Standard', fontSize+2,...
				epochName, subjSess{1}, subjSess{2}(1:4), subjSess{2}(5:6), subjSess{2}(7:8) ), 'FontSize', fontSize )
			title( hAx(4), sprintf( '\\color{red}Novel (%d/%d)', nnz( Knovel ), Nnovel ), 'FontSize', fontSize )
			title( hAx(5), '\color{red}Novel - Standard', 'FontSize', fontSize )
			ylabel( hAx(1), '(\muV)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			for iSet = 1:nSet
				ylabel( hAx(5+4*iSet-3), [ chanSet{iSet,1}, ' (\muV)' ], 'FontSize', fontSize, 'FontWeight', 'bold' )
			end
			xlabel( hAx(1)         , 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(5+4*nSet-3), 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(5+4*nSet-2), 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(5+4*nSet-1), 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
			xlabel( hAx(5+4*nSet)  , 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
% 			title(  hAx(5+4*nSet+1), 'Target'           , 'FontSize', fontSize )
% 			title(  hAx(5+4*nSet+2), 'Target - Standard', 'FontSize', fontSize )
% 			title(  hAx(5+4*nSet+3), 'Novel'            , 'FontSize', fontSize )
% 			title(  hAx(5+4*nSet+4), 'Novel - Standard' , 'FontSize', fontSize )
			ylabel( hAx(5+4*nSet+1), tStr1T, 'Visible', 'on', 'Color', pkColorT, 'FontSize', fontSize, 'FontWeight', 'bold' )
			ylabel( hAx(5+4*nSet+3), tStr1N, 'Visible', 'on', 'Color', pkColorN, 'FontSize', fontSize, 'FontWeight', 'bold' )
			ylabel( hAx(5+4*nSet+5), tStr2T, 'Visible', 'on', 'Color',      'k', 'FontSize', fontSize, 'FontWeight', 'bold' );
			ylabel( hAx(5+4*nSet+7), tStr2N, 'Visible', 'on', 'Color',      'k', 'FontSize', fontSize, 'FontWeight', 'bold' );

			iSet(:) = find( kSetT );
			if tWidthTopo == 0
				line( hAx(5+4*iSet-2), EEG.times([jtT,jtT]), yRange, 'Color', pkColorT, 'LineStyle', '--' )
			else
				uistack( patch( hAx(5+4*iSet-2), EEG.times(jtT)+[-1,1,1,-1]*tWidthTopo/2, yRange([1 1 2 2]), repmat( 0.75, 1, 3 ), 'EdgeColor', 'none', 'FaceAlpha', 0.5 ), 'bottom' )
% 				line( hAx(5+4*iSet), EEG.times([jtT,jtT]), yRange, 'Color', pkColorT, 'LineStyle', '--' )
			end
			iSet(:) = find( kSetN );
			if tWidthTopo == 0
				line( hAx(5+4*iSet), EEG.times([jtN,jtN]), yRange, 'Color', pkColorN, 'LineStyle', '--' )
			else
				uistack( patch( hAx(5+4*iSet), EEG.times(jtN)+[-1,1,1,-1]*tWidthTopo/2, yRange([1 1 2 2]), repmat( 0.75, 1, 3 ), 'EdgeColor', 'none', 'FaceAlpha', 0.5 ), 'bottom' )
% 				line( hAx(5+4*iSet), EEG.times([jtN,jtN]), yRange, 'Color', pkColorN, 'LineStyle', '--' )
			end

%{
			hAx2 = gobjects( 1, 3 );
			hFig(2) = figure( 'Position', [ 650, 200, 1000, 250 ], 'MenuBar', 'none' );
			hAx2(1) = subplot( 1, 3, 1 );
				plot( EEG.times(jTime), YmStandard' )
				ylim( [ -1, 1 ] * max( abs( YmStandard ), [], 'all' ) * 1.05 )
			hAx2(2) = subplot( 1, 3, 2 );
				plot( EEG.times(jTime), YmTarget' )
				ylim( [ -1, 1 ] * max( abs( YmTarget ), [], 'all' ) * 1.05 )
			hAx2(3) = subplot( 1, 3, 3 );
				plot( EEG.times(jTime), YmNovel' )
				ylim( [ -1, 1 ] * max( abs( YmNovel ), [], 'all' ) * 1.05 )
			set( hAx2, 'XGrid', 'on', 'YGrid', 'on', 'XLim', tWinPlot )
			set([
					title(  hAx2(1), sprintf( 'Standard (%d)', nnz( Kstandard ) ) )
					title(  hAx2(2), sprintf(   'Target (%d)', nnz( Ktarget   ) ) )
					title(  hAx2(3), sprintf(    'Novel (%d)', nnz( Knovel    ) ) )
					ylabel( hAx2(1), sprintf( '%s\n%s-%s-%s\nMean %s ERP (\\muV)', subjSess{1}, subjSess{2}(1:4), subjSess{2}(5:6), subjSess{2}(7:8), epochName ) )
					xlabel( hAx2(1), 'Time (ms)' )
					xlabel( hAx2(2), 'Time (ms)' )
					xlabel( hAx2(3), 'Time (ms)' )
				], 'FontSize', 12 )
%}
			if plotHeralds ~= 0
				hAxA  = gobjects( nSet + 2, 1 );
				nStd  = nnz( Kstandard & ~KpreNovel );
				nPre  = nnz( Kstandard &  KpreNovel );
				nBoth = nStd + nPre;
				IPerm = [ find( Kstandard & ~KpreNovel ), find( Kstandard &  KpreNovel ) ];
				nPerm = 0;	%5e3;
				rgbPre  = [ 0, 0.75, 0 ];
				rgbPreT = [ 2/3, 0, 1 ];
				
				yMax = 0;
				for iSet = 1:nSet
					yStd  = mean( mean( EEG.data(chanSet{iSet,2},jTime,Kstandard & ~KpreNovel ), 3, nanFlag ), 1, nanFlag );
					yPre  = mean( mean( EEG.data(chanSet{iSet,2},jTime,Kstandard &  KpreNovel ), 3, nanFlag ), 1, nanFlag );
					yPreT = mean( mean( EEG.data(chanSet{iSet,2},jTime,Kstandard &  KpreTarget), 3, nanFlag ), 1, nanFlag );
					yMax(:) = max( [ yMax, abs( [ yStd, yPre, yPre-yStd, yPreT, yPreT-yStd  ] ) ] );
					hAxA(iSet) = subplot( 'Position', [ axL, 1 - axT  - axH*(iSet+1) - axGv(1)*iSet, axW, axH ] );
					hLineA = plot( EEG.times(jTime), yStd, 'k', EEG.times(jTime), yPre, '--k', EEG.times(jTime), yPreT, ':k' );
					set( hLineA(2), 'LineStyle', '-', 'Color', rgbPre )
					set( hLineA(3), 'LineStyle', '-', 'Color', rgbPreT )
					if nPerm ~= 0
						dY    = yPre - yStd;
						sigma = zeros( 1, nTime );
						for iPerm = 1:nPerm
							IPerm(:) = IPerm(randperm( nBoth ));
							sigma(:) = sigma + ( (...
								mean( mean( EEG.data(chanSet{iSet,2},jTime,IPerm(nStd+1:nBoth)), 3, nanFlag ), 1, nanFlag ) -...
								mean( mean( EEG.data(chanSet{iSet,2},jTime,IPerm(1:nStd))      , 3, nanFlag ), 1, nanFlag ) ) < dY );
						end
						sigma(:) = norminv( ( sigma + 0.5 ) / ( nPerm + 1 ) );		% prevent Inf
						kSig = abs( sigma ) > 3;
%						max( abs( sigma ) )
						Ion  = find( kSig & [ true, ~kSig(1:nTime-1) ] );
						Ioff = find( kSig & [ ~kSig(2:nTime), true   ] );
						JTime = find( jTime );		% what a pain
%						for iOn = 1:numel( Ion )
%							plot( EEG.times(JTime([Ion(iOn),Ioff(iOn)])), [ 0, 0 ], 'Color', [ 1, 0.5, 0.5 ], 'LineWidth', 3 )
%						end
						hold( hAxA(iSet), 'on' )
						for iOn = 1:numel( Ion )
							plot( hAxA(iSet), EEG.times(JTime(Ion(iOn):Ioff(iOn))), yPre(Ion(iOn):Ioff(iOn)), 'Color', [ 1, 0, 0 ], 'LineWidth', 2 )
						end
						hold( hAxA(iSet), 'off' )
					end
					ylabel( hAxA(iSet), [ chanSet{iSet,1}, ' (\muV)' ], 'FontSize', fontSize, 'FontWeight', 'bold' )
					ylabel( hAx(5+4*iSet-3), '' )
				end
				yRangeA = yRangeFcn( yMax );

				% topoOpts = { 'style', 'map', 'electrodes', 'pts', 'nosedir', '+X', 'conv', 'on', 'shading', 'interp', 'maplimits', yRange };
				% topoOpts = { 'nosedir', '+X', 'style', 'map', 'colormap', jet(256), 'shading', 'flat', 'conv', 'on',...
				% 	'headrad', 0.5, 'electrodes', 'on', 'emarker', { '.', 'k', 8, 0.5 }, 'hcolor', repmat( 0.333, 1, 3 ),...
				% 	'gridscale', 200, 'circgrid', 360, 'maplimits', yRange };
% 				topoOpts{ find( strcmp( topoOpts(1:2:end), 'colormap'  ) ) * 2 } = parula( 256 );		% changes existing topos too
				topoOpts{ find( strcmp( topoOpts(1:2:end), 'maplimits' ) ) * 2 } = yRangeA;

				tFix = 128;
				tAvg = tFix + [ -1, 1 ]*wFix/2;
				jAvg = EEG.times >= tAvg(1) & EEG.times <= tAvg(2);
				tPre = mean( mean( EEG.data(Ichan,jAvg,Kstandard &  KpreNovel), 3, nanFlag ), 2, nanFlag );
				tStd = mean( mean( EEG.data(Ichan,jAvg,Kstandard & ~KpreNovel), 3, nanFlag ), 2, nanFlag );
				zMax = max( abs( tPre - tStd ) );
				hAxA(nSet+1) = subplot( 'Position', [ axL, 1 - axT  - axH*(1+nSet+1) - axGv(1)*nSet - axGv(2)          , axW, axH ] );
					topoplot( tPre-tStd, EEG.chanlocs(Ichan), topoOpts{:} );
					ylabel( hAxA(nSet+1), sprintf( 'Fixed Window\n%0.0f \\pm %0.0f ms', tFix, wFix/2 ), 'Visible', 'on', 'Color', 'k', 'FontSize', fontSize, 'FontWeight', 'bold' )
				tFix = 325;
				tAvg = tFix + [ -1, 1 ]*wFix/2;
				jAvg = EEG.times >= tAvg(1) & EEG.times <= tAvg(2);
				tPre = mean( mean( EEG.data(Ichan,jAvg,Kstandard &  KpreNovel), 3, nanFlag ), 2, nanFlag );
				tStd = mean( mean( EEG.data(Ichan,jAvg,Kstandard & ~KpreNovel), 3, nanFlag ), 2, nanFlag );
				zMax(:) = max( [ zMax; abs( tPre - tStd ) ] );
				hAxA(nSet+2) = subplot( 'Position', [ axL, 1 - axT  - axH*(1+nSet+2) - axGv(1)*nSet - axGv(2) - axGv(3), axW, axH ] );
					topoplot( tPre-tStd, EEG.chanlocs(Ichan), topoOpts{:} );
					ylabel( hAxA(nSet+2), sprintf( 'Fixed Window\n%0.0f \\pm %0.0f ms', tFix, wFix/2 ), 'Visible', 'on', 'Color', 'k', 'FontSize', fontSize, 'FontWeight', 'bold' )

				set( hAxA(1:nSet), 'XLim', tWinPlot, 'FontSize', 8, 'XGrid', 'on', 'YGrid', 'on',...
					'XTick', fix(tWinPlot(1)/100)*100:100:fix(tWinPlot(2)/100)*100, 'Box', 'on', 'YLim', yRangeA )
				set( hAx(1)        , 'XTickLabel', '' )
				set( hAxA(1:nSet-1), 'XTickLabel', '' )
				set( hAxA(nSet+1:nSet+2), 'XLim', [ -0.5, 0.5 ], 'YLim', [ -0.4, 0.45 ], 'CLim', yRangeA )
				xlabel( hAx(1), '' )
				xlabel( hAxA(nSet), 'Time (ms)', 'FontSize', fontSize, 'FontWeight', 'bold' )
% 				xlabel( hAxA(nSet+2), 'Herald - Non', 'FontSize', fontSize, 'FontWeight', 'bold', 'Visible', 'on' )
				title( hAxA(nSet+1), 'Herald - Non', 'FontSize', fontSize, 'FontWeight', 'bold' )
				title(  hAxA(1), sprintf( '\\color[rgb]{%g,%g,%g}Novel Herald', rgbPre  ), 'FontSize', fontSize, 'FontWeight', 'bold' )
				title(  hAxA(2), sprintf( '\\color[rgb]{%g,%g,%g}Pre-Target Standard', rgbPreT ), 'FontSize', fontSize, 'FontWeight', 'bold' )
				
				if globalCmap
					% AOD novel herald topo colorbar
					% iSet = ?;		leave colorbar on lowest axis?
					wColorbar = 0.3;		% width relative to gap between axes
					hColorbar = subplot( 'Position', [ axL+axW+axGh*(1-wColorbar)/2, 1-axT+axGv(1)-(axGv(1)+axH)*(1+iSet), axGh*wColorbar, axH ], 'Parent', hFig(1) );
					image( hColorbar, (256:-1:1)' )
					set( hColorbar, 'YLim', [ 0.5, 256.5 ], 'XTick', [], 'YTick', [] )				
				else
					set( hAxA(nSet+1:nSet+2), 'CLim', [ -1, 1 ] * zMax )
					hColorbar = subplot( 'Position', [ axL, axB*(1-wColorbar)*0.7, axW, axB*wColorbar ], 'Parent', hFig(1) );
					image( hColorbar, linspace( -zMax, zMax, 256 ), 0, (1:256) )
					set( hColorbar, 'YTick', [] )
				end
				
			end

		otherwise
	end

	% main topo colorbar
	if globalCmap
		% iSet = ?;		leave colorbar on lowest axis?
		wColorbar = 0.3;		% width relative to border @ right
		hColorbar = subplot( 'Position', [ 1-axR*(1+wColorbar)/2, 1-axT+axGv(1)-(axGv(1)+axH)*(1+iSet), axR*wColorbar, axH ], 'Parent', hFig(1) );
		image( hColorbar, (256:-1:1)' )
		set( hColorbar, 'YLim', [ 0.5, 256.5 ], 'XTick', [], 'YTick', [] )
	else
	end
	
	set( hFig(1), 'Color', 'w' )
	figure( hFig(1) )

	pngDir = fullfile( AMPSCZ_EEG_procSessionDir( subjSess{1}, subjSess{2} ), 'Figures' );
	if ~isfolder( pngDir )
		mkdir( pngDir )
		fprintf( 'created %s\n', pngDir )
	end

% 	pngOut = fullfile( pngDir, [ subjSess{1}, '_', subjSess{2}, '_', epochName, '.png' ] );
	pngOut = fullfile( pngDir, [ subjSess{1}, '_', subjSess{2}, '_', epochName, '_', filterStr, '.png' ] );

	if isempty( writeFlag )
		writeFlag = exist( pngOut, 'file' ) ~= 2;		
		if ~writeFlag
			writeFlag(:) = strcmp( questdlg( [ 'Replace ', epochName ' png?' ], mfilename, 'no', 'yes', 'no' ), 'yes' );
		end
	end
	if writeFlag
		% print( hFig, ... ) & saveas( hFig, ... ) don't preserve pixel dimensions
		figPos = get( hFig(1), 'Position' );		% is this going to work on BWH cluster when scheduled w/ no graphical interface?
		img = getframe( hFig(1) );
		img = imresize( img.cdata, figPos(4) / size( img.cdata, 1 ), 'bicubic' );		% scale by height
		imwrite( img, pngOut, 'png' )
		fprintf( 'wrote %s\n', pngOut )
	end

	numel( hTopo );		% suppress warning indicator for unused hTopo

	return

	function yRange = yRangeFcn( Y )
		% extrema
		yRange = [ min( Y, [], 'all' ), max( Y, [], 'all' ) ];
		% make symmetric about zero
		yRange(2) = max( -yRange(1), yRange(2) );
		yRange(1) = -yRange(2);
		% pad a little?
		yRange(:) = yRange + [ -1, 1 ] * diff( yRange ) * 0.125;
	end
	
	% this is replicated in AMPSCZ_EEG_makeMovie.m
	function yTick = yTickFcn( yExt )
		% gives denser but ~sensible y axis ticks than Matlab defaults
		power10scale = 10^floor( log10( yExt ) );
		switch floor( yExt / power10scale )
			case 1
				yTickInc = 0.5;
			case {2,3}
				yTickInc = 1;
			case {4,5,6,7}
				yTickInc = 2;
			case {8,9}
				yTickInc = 4;
			otherwise
				error( 'YTick bug' )
		end
		yTickInc(:) = yTickInc * power10scale;
		nYTick = floor( yExt / yTickInc );
		yTick = (-nYTick:1:nYTick) * yTickInc;
	end
	

%{

	% relics of interactive peak picking, won't work as is!

	function sliceClickCB( varargin )
		if varargin{2}.Button ~= 3
			return
		end
		g = ginput( 1 );
		if g(1) <= tWinPlot(1) || g(1) >= tWinPlot(2)
			return
		end
		% what peak are you modifying? 1=standard, 2=target, 3=novel
		iiPk = get( varargin{1}, 'UserData' );
		% move the line.  note: hTime(iiPk) is varargin{1}
		[ ~, jPk(iiPk) ] = min( abs( EEG.times(jTime) - g(1) ) );
		set( hTime(iiPk), 'XData', EEG.times(jPk([ iiPk, iiPk ])+jT0) )
		getTopoMaps
		% note: topoplot( ..., 'noplot', 'on' ) was a complete fail.  closes figure.  put a copy in my modification folder.
		switch iiPk
			case 1
			case 2
				[ ~, cdata ] = topoplot( tmStandardT, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(1), 'CData', cdata )
				set( ylabT, 'String', sprintf( '%0.0f ms', EEG.times(jPk(iiPk)+jT0) ) )
				
				[ ~, cdata ] = topoplot( tmTarget, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(2), 'CData', cdata )
				
				[ ~, cdata ] = topoplot( tmTarget - tmStandardT, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(3), 'CData', cdata )
			case 3
				iTopo = 3*doTarget;
				[ ~, cdata ] = topoplot( tmStandardN, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(iTopo+1), 'CData', cdata )
				set( ylabN, 'String', sprintf( '%0.0f ms', EEG.times(jPk(iiPk)+jT0) ) )
				
				[ ~, cdata ] = topoplot( tmNovel, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(iTopo+2), 'CData', cdata )
				
				[ ~, cdata ] = topoplot( tmNovel - tmStandardN, EEG.chanlocs(Ichan), topoOpts{:}, 'noplot', 'on' );
				set( hTopo(iTopo+3), 'CData', cdata )
		end
% 		title( hAx(1), sprintf( '%s \\color[rgb]{0,0.75,0}%0.0f ms', epochName, EEG.times(jPk) ) )
% 		xlabel( hAx(nSet), sprintf( '%0.0f ms', EEG.times(jPk+jT0) ) )
% 		set( xLab, 'String', sprintf( '%0.0f ms', EEG.times(jPk+jT0) ) )

	end

	function getTopoMaps
% 		iiPk = find(~isnan(jPk),1,'first');
		if isnan( jPk(2) )
			tmStandardT(:) = nan;
			tmTarget(:)    = nan;
		elseif tWidthTopo == 0
			tmStandardT(:) = YmStandard(:,jPk(2));
			tmTarget(:)    =   YmTarget(:,jPk(2));
		else
% 			jt   = jPk(iiPk) + jT0;
% 			jAvg = EEG.times(jTime) >= EEG.times(jt) - tWidthTopo/2 & EEG.times(jTime) <= EEG.times(jt) + tWidthTopo/2;
% 			tmStandard   = mean( YmStandard(:,jAvg), 2, 'includenan' );
			jt   = jPk(2) + jT0;
			jAvg = EEG.times(jTime) >= EEG.times(jt) - tWidthTopo/2 & EEG.times(jTime) <= EEG.times(jt) + tWidthTopo/2;
			tmStandardT(:) = mean( YmStandard(:,jAvg), 2, 'includenan' );
			tmTarget(:)    = mean(   YmTarget(:,jAvg), 2, 'includenan' );
		end
		if isnan( jPk(3) )
			tmStandardN(:) = nan;
			tmNovel(:)     = nan;
		elseif tWidthTopo == 0
			tmStandardN(:) = YmStandard(:,jPk(3));
			tmNovel(:)     =    YmNovel(:,jPk(3));
		else
			jt(:)   = jPk(3) + jT0;
			jAvg(:) = EEG.times(jTime) >= EEG.times(jt) - tWidthTopo/2 & EEG.times(jTime) <= EEG.times(jt) + tWidthTopo/2;
			tmStandardN(:) = mean( YmStandard(:,jAvg), 2, 'includenan' );
			tmNovel(:)     = mean(    YmNovel(:,jAvg), 2, 'includenan' );
		end
	end


%}


%%
%{
	AMPSCZdir = AMPSCZ_EEG_paths;

	proc = AMPSCZ_EEG_findProcSessions;
	
	taskName = { 'MMN', 'VOD', 'AOD' };
	for iProc = 6%4:size(proc,1)
		close all
		matDir = fullfile( AMPSCZ_EEG_procSessionDir( proc{iProc,2}, proc{iProc,3}, proc{iProc,1}(1:end-2) ), 'mat' );
		for iTask = 1%1:numel( taskName )
			AMPSCZ_EEG_ERPplot( fullfile( matDir, [ proc{iProc,2}, '_', proc{iProc,3}, '_', taskName{iTask}, '_[0.1,50].mat' ] ) )
		end
	end
%}
%%
	
end


